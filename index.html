<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bububurger - Menú</title>
  <style>
    body {
      margin: 0;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: #fff200; /* Amarillo vibrante */
      flex-direction: column;
      font-family: Arial, sans-serif;
      color: #000;
    }
    img {
      max-width: 250px;
      height: auto;
      animation: pulse 1.5s infinite;
      user-select: none;
    }
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    p { margin-top: 15px; font-weight: bold; font-size: 18px; }
  </style>
</head>
<body>
  <img src="logo-bubu.png" alt="Bububurger">
  <p>Cargando menú...</p>

  <script>
    // === Config ===
    const SCRIPT_URL = "https://script.google.com/macros/s/AKfycbzB8UVibJniBM_nLe6LSRRVeuV9OGZIVl1fN6gJYSaYz7cnLWKU0dJUqwn1a61ZEEAB/exec"; // v4
    const MENU_URL   = "https://menu-bububurger.netlify.app/";
    const REDIRECT_DELAY = 2500;  // ¡se queda en 2.5s!
    const LOG_TIMEOUT    = 1200;  // tiempo máx. para intento fetch
    const DEDUP_MS       = 15000; // ventana anti-duplicado (cliente)

    // === Utilidades ===
    function nowId() { return `${Date.now()}-${Math.random().toString(36).slice(2,8)}`; }

    async function getClientIP() {
      try {
        const r = await fetch("https://api.ipify.org?format=json", {cache:"no-store"});
        const j = await r.json();
        return j.ip || "unknown";
      } catch { return "unknown"; }
    }

    // Envía el log con sendBeacon o fetch(keepalive). Devuelve true si lo intentó.
    function sendLogPayload(payloadStr) {
      try {
        // 1) Preferir sendBeacon (funciona al navegar/salir)
        if (navigator.sendBeacon) {
          const ok = navigator.sendBeacon(SCRIPT_URL, new Blob([payloadStr], { type: "application/json" }));
          if (ok) return true;
        }
        // 2) Respaldo con fetch + keepalive + timeout
        const ctrl = new AbortController();
        const timer = setTimeout(() => ctrl.abort(), LOG_TIMEOUT);
        fetch(SCRIPT_URL, {
          method: "POST",
          mode: "no-cors",
          headers: { "Content-Type": "application/json" },
          body: payloadStr,
          signal: ctrl.signal,
          keepalive: true
        }).catch(() => {}).finally(() => clearTimeout(timer));
        return true;
      } catch {
        return false;
      }
    }

    let sentOnce = false; // evita múltiples envíos locales

    async function logScan() {
      try {
        // Anti-duplicado en cliente
        const now = Date.now();
        const last = Number(sessionStorage.getItem("bubu_last_log") || 0);
        if (now - last < DEDUP_MS) return;
        sessionStorage.setItem("bubu_last_log", String(now));

        const ip  = await Promise.race([ getClientIP(), new Promise(res => setTimeout(() => res("timeout"), 800)) ]);
        const ua  = navigator.userAgent || "unknown";
        const tz  = Intl.DateTimeFormat().resolvedOptions().timeZone || "unknown";
        const ref = document.referrer || "direct";
        const eid = nowId();

        const payload = JSON.stringify({ ip, ua, tz, ref, path: location.href, eid });
        sentOnce = sendLogPayload(payload);

        // Reintento discreto a los ~600ms si no hubo intento (extremadamente raro)
        setTimeout(() => { if (!sentOnce) sendLogPayload(payload); }, 600);

        // Enviar también al salir/ocultar como seguro adicional (no duplica por eid)
        const finalize = () => { sendLogPayload(payload); };
        document.addEventListener("visibilitychange", () => {
          if (document.visibilityState !== "visible") finalize();
        }, { once: true });
        window.addEventListener("pagehide", finalize, { once: true });

      } catch {/* no bloquear */}
    }

    // Flujo principal
    (async () => {
      logScan();                          // Enviar al entrar
      setTimeout(() => {
        // Ping final justo antes de redirigir (seguro con sendBeacon)
        // (El servidor ignora duplicados por eid)
        // *No generamos nuevo eid aquí para no duplicar*
        // Nota: si quieres, podríamos generar otro eid distinto para "post-redirect",
        // pero con Cache + dedupe cliente ya es suficiente.
        // Redirigir
        window.location.href = MENU_URL;
      }, REDIRECT_DELAY);
    })();
  </script>
</body>
</html>
